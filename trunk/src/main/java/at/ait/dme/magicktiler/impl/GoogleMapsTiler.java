package at.ait.dme.magicktiler.impl;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;

import org.apache.log4j.Logger;
import org.im4java.core.IM4JavaException;

import at.ait.dme.magicktiler.ImageInfo;
import at.ait.dme.magicktiler.MagickTiler;
import at.ait.dme.magicktiler.TilesetInfo;
import at.ait.dme.magicktiler.TilingException;

/**
 * A tiler that implements the Google Maps tiling scheme
 * <br><br>
 * <b>Developer info...</b><br>
 * <em>If you just want to generate Google Map tiles and use them, and 
 * don't need to understand how it works internally - <b>just 
 * ignore this section!</b></em>
 * <br><br>
 * The Google Maps tiling scheme
 * arranges tiles in the following folder/file structure:
 * <br><br>
 * /tileset-root/[zoomlevel]-[column]-[row].jpg (or .png)
 * <br><br>
 * The highest-resolution zoom level has the highest number. Column/row
 * numbering of tiles starts top/left, counting direction is right/downwards.
 * <br><br>
 * The implemented tiling algorithm works as follows:
 * <ol>
 * <li>Resize the image to the closest multiple of 256 and the power of 2</li>
 * <li>Then square the image using the longest dimension, 
 * filling the empty space with the background color. </li>
 * <li>For all zoomlevels we create a base image with a width/height of 256*2^zoomlevel</li>
 * <li>These base images are cut into tiles: The number of tiles per zoomlevel is 4^(zoomlevel)</li>
 * <li>HTML preview file is generated (if requested).</li>
 * </ol>
 
 * @author Christian Sadilek <christian.sadilek@gmail.com>
 */
public class GoogleMapsTiler extends MagickTiler {
	private static Logger log = Logger.getLogger(GoogleMapsTiler.class);

	@Override
	protected TilesetInfo convert(File image, TilesetInfo info) throws TilingException {
		TilesetInfo updatedInfo = null;
		long startTime = System.currentTimeMillis();
		log.info("Generating Google Map tiles for file " + image.getName());	
		
		try {
			log.debug("Resizing and squaring base image");
			String baseImageFileName = tilesetRootDir.getAbsolutePath()+"/base."+processor.getImageFormat().getExtension();
			
			// Step 1: resize to the closest multiple of 256 and the power of 2
			ImageInfo resizedImage=resizeBaseImage(image, info, baseImageFileName);
			
			// Step 2: square the image
			ImageInfo squaredImage=squareBaseImage(resizedImage, baseImageFileName);
			
			// reinitialize the tileset info based on the new base image
			updatedInfo = new TilesetInfo(squaredImage.getFile(), tileWidth, tileHeight, processor);	
			
			for(int z=0;z<updatedInfo.getZoomLevels();z++) {
				log.debug("Tiling level " + z);
				String tilesBaseFileName = tilesetRootDir.getAbsolutePath()+File.separator+z;
				
				// Step 3: create a base image for this zoomlevel
				int dim = 256*(int)Math.pow(2, z);
				baseImageFileName = tilesetRootDir.getAbsolutePath()+File.separator+"base"+z+"."+processor.getImageFormat().getExtension();
				resizeImage(squaredImage.getFile().getAbsolutePath(), baseImageFileName, dim, dim);
				File baseImageFile = new File(baseImageFileName);
				TilesetInfo baseInfo = 
					new TilesetInfo(baseImageFile, tileWidth, tileHeight, processor);	
	
				// Step 4: create the tiles for this zoomlevel
				// as the offset is omitted when calling crop, it creates tiles for the entire input image. 
				// this is also a performance improvement compared to generating each tile separately.
				processor.crop(baseImageFileName, 
						tilesBaseFileName+"_"+"%d"+"."+processor.getImageFormat().getExtension(), 
						tileWidth, 
						tileHeight);
				
				// we need to rename the files generated by graphics/image magick
				for(int x=0,i=0;x<baseInfo.getNumberOfXTiles(0);x++) {
					for(int y=0;y<baseInfo.getNumberOfYTiles(0);y++,i++) {
						File fOld = new File(tilesBaseFileName+"_"+i+"."+processor.getImageFormat().getExtension());
						File fNew = new File(tilesBaseFileName+"_"+y+"_"+x+"."+processor.getImageFormat().getExtension());
						if(!fOld.renameTo(fNew)) throw new TilingException("Failed to rename file:"+fOld);
					}
				}
				if(!baseImageFile.delete()) log.error("Could not delete file:"+baseImageFile);
			}
			if(!squaredImage.getFile().delete()) log.error("Could not delete file:"+squaredImage.getFile());
			
			//step 5: optionally create preview.html
			if(generatePreview) generatePreview(info, updatedInfo);
			log.info("Took " + (System.currentTimeMillis() - startTime) + " ms.");
		} catch (Exception e) {
			log.error("Failed to resize image", e);
			throw new TilingException(e.getMessage());
		} 
		
		return updatedInfo;
	}
	
	private ImageInfo squareBaseImage(ImageInfo imageInfo, String targetImageFileName) 
		throws IOException, InterruptedException, IM4JavaException, TilingException {	
		
		int maxDim=Math.max(imageInfo.getHeight(), imageInfo.getWidth());
		processor.square(imageInfo.getFile().getAbsolutePath(), targetImageFileName, maxDim);
		return new ImageInfo(new File(targetImageFileName), processor.getImageProcessingSystem());
	}

	private ImageInfo resizeImage(String src, String target, int width, int height) 
		throws IOException, InterruptedException, IM4JavaException, TilingException {
		
		processor.resize(src, target, width, height);
		return new ImageInfo(new File(target), processor.getImageProcessingSystem());
	}
	
	private ImageInfo resizeBaseImage(File image, TilesetInfo info, String targetFileName) 
		throws IOException, InterruptedException, IM4JavaException, TilingException {
		
		// find the closest multiple of 256 and the power of 2
		int maxDim = Math.max(info.getWidth(), info.getHeight());
		int newMaxDim=0,prevMaxDim=0;
		for(int pow=0; newMaxDim<maxDim; pow++) {
			prevMaxDim = newMaxDim;
			newMaxDim = 256 * (int)(Math.pow(2, pow));
		}
		if(Math.abs(maxDim-prevMaxDim) < Math.abs(maxDim-newMaxDim)) newMaxDim = prevMaxDim;
		
		// calculate the new height and width
		int newHeight=0,newWidth=0;
		if(maxDim==info.getHeight())  {
			newHeight=newMaxDim;
			newWidth=newHeight * (int)Math.ceil(((float)info.getWidth()/info.getHeight()));
		} else {
			newWidth=newMaxDim;
			newHeight=newWidth * (int)Math.ceil(((float)info.getHeight()/info.getWidth()));
		}
		
		return resizeImage(image.getAbsolutePath(), targetFileName, newWidth, newHeight);
	}
	
	private void generatePreview(TilesetInfo info, TilesetInfo updatedInfo) throws IOException {
		BufferedReader reader = null;
		try {
			reader = new BufferedReader(new InputStreamReader(this.getClass()
						.getResourceAsStream("gmap-template.html")));
	
			StringBuffer sb = new StringBuffer();
			String line;
			while ((line = reader.readLine()) != null) {
				sb.append(line + "\n");
			}
			
			String html = sb.toString()
				.replace("@title@", info.getImageFile().getName())
				.replace("@zoomlevels@", Integer.toString(updatedInfo.getZoomLevels() ))
				.replace("@maxzoom@", Integer.toString(updatedInfo.getZoomLevels() - 1))
				.replace("@tilesetpath@", tilesetRootDir.getAbsolutePath().replace("\\", "/")+"/")
				.replace("@ext@", info.getTileFormat().getExtension());
			
			writeHtmlPreview(html);
		} finally {
			if(reader!=null) reader.close();
		}
	}
}
